<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WikiFractal | Frictionless Nav</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600&family=Inter:wght@300;400&display=swap');

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            background: radial-gradient(circle at 50% 50%, #0a0a0f 0%, #000000 100%);
            color: #e2e8f0; 
            font-family: 'Inter', sans-serif; 
            overflow: hidden;
            width: 100vw; 
            height: 100vh;
            user-select: none; /* Prevent accidental text highlighting while dragging */
        }

        /* --- Viewport & World --- */
        #viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: default;
            position: relative;
            touch-action: none; /* Crucial for smooth gestures */
        }
        
        /* The infinite surface */
        #world {
            position: absolute;
            display: flex;
            /* Start with plenty of padding so we aren't pinned to edge */
            padding: 50vh 50vw; 
            transform-origin: 0 0;
            will-change: transform;
            /* No transition during drag for 60fps performance */
        }

        /* --- Tree Structure --- */
        .node-wrapper {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 80px; /* More breathing room */
            position: relative;
        }

        .children-stack {
            display: flex;
            flex-direction: column;
            gap: 40px;
            position: relative;
            padding-left: 0;
        }

        /* --- Connectors --- */
        /* Horizontal Branch */
        .node-wrapper > .children-stack::before {
            content: '';
            position: absolute;
            left: -80px; /* Match gap */
            top: 50%;
            width: 80px;
            height: 2px;
            background: #333;
        }

        /* Vertical Spine */
        .children-stack::after {
            content: '';
            position: absolute;
            left: -80px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #333;
        }
        
        /* Hide spine for single child */
        .children-stack > .node-wrapper:only-child::after { display: none; }
        
        /* Spine Clipping (Don't draw line above first child or below last child) */
        .children-stack > .node-wrapper:first-child::after {
            content: ''; position: absolute; left: -80px; top: -50px; bottom: 50%; width: 4px; background: #0a0a0f; z-index: 1;
        }
        .children-stack > .node-wrapper:last-child::after {
            content: ''; position: absolute; left: -80px; top: 50%; bottom: -50px; width: 4px; background: #0a0a0f; z-index: 1;
        }

        /* --- Card UI --- */
        .card {
            width: 450px;
            height: 600px;
            background: #121216;
            border: 1px solid #2a2a30;
            border-radius: 12px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transition: border-color 0.2s;
            user-select: text; /* Allow text selection inside card */
        }
        
        .card:hover { border-color: #444; }
        .card.active { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }

        .card-header {
            padding: 16px 24px;
            background: #18181c;
            border-bottom: 1px solid #2a2a30;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: grab; /* Header is a drag handle for the map */
        }
        .card-header:active { cursor: grabbing; }

        .card-body {
            flex: 1;
            overflow-y: auto; /* Enable Scroll */
            padding: 24px;
            font-size: 1rem;
            line-height: 1.6;
            color: #ccc;
            /* Smooth scroll behavior */
            scrollbar-width: thin;
            scrollbar-color: #444 #121216;
        }
        
        /* Prevent scroll chaining (Scrolling text doesn't move map) */
        .card-body { overscroll-behavior: contain; }

        /* Wiki Typography */
        .wiki-text h2 { font-family: 'Space Grotesk'; font-size: 1.4rem; color: #fff; margin: 1.5rem 0 0.5rem 0; }
        .wiki-text p { margin-bottom: 1rem; }
        .wiki-text a { color: #60a5fa; text-decoration: none; border-bottom: 1px solid rgba(96,165,250,0.2); cursor: pointer; }
        .wiki-text a:hover { background: rgba(59,130,246,0.1); }
        .wiki-text img { max-width: 100%; border-radius: 6px; margin: 10px 0; }

        /* Search & Controls */
        .ui-layer {
            position: fixed;
            z-index: 100;
            pointer-events: none; /* Let clicks pass through to map */
            width: 100%;
            height: 100%;
            top: 0; left: 0;
        }
        
        .search-bar {
            pointer-events: auto;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20,20,25,0.9);
            backdrop-filter: blur(10px);
            border: 1px solid #333;
            border-radius: 30px;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .nav-hint {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: flex;
            gap: 20px;
            font-size: 0.8rem;
            color: #666;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid #222;
        }
        
        .key { background: #333; color: #fff; padding: 2px 6px; border-radius: 4px; margin-right: 4px; }

        /* Loading Spinner */
        .spinner { border: 3px solid rgba(255,255,255,0.1); border-top: 3px solid #3b82f6; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .suggestions {
            pointer-events: auto;
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            background: #1a1a20;
            border: 1px solid #333;
            border-radius: 12px;
            display: none;
        }
        .suggestions.active { display: block; }
        .s-item { padding: 12px 20px; border-bottom: 1px solid #222; cursor: pointer; color: #ccc; }
        .s-item:hover { background: #222; color: #fff; }
    </style>
</head>
<body>

    <div class="ui-layer">
        <div class="search-bar">
            <i class="ri-search-line text-gray-500"></i>
            <input type="text" id="searchInput" placeholder="Search..." class="bg-transparent border-none outline-none text-white w-full h-8 text-sm">
            <div id="loader" class="spinner hidden"></div>
        </div>
        <div id="suggestions" class="suggestions"></div>

        <div class="nav-hint">
            <span><span class="key">Scroll</span> Pan View</span>
            <span><span class="key">Hover</span> Scroll Text</span>
            <span><span class="key">Ctrl+Scroll</span> Zoom</span>
            <span><span class="key">Drag</span> Pan</span>
        </div>
    </div>

    <div id="viewport">
        <div id="world"></div>
    </div>

    <script>
        // --- State ---
        const state = {
            scale: 1,
            x: 0,
            y: 0,
            isDragging: false,
            startX: 0,
            startY: 0
        };

        const dom = {
            world: document.getElementById('world'),
            viewport: document.getElementById('viewport'),
            input: document.getElementById('searchInput'),
            suggestions: document.getElementById('suggestions')
        };

        const API = 'https://en.wikipedia.org/w/api.php?origin=*';

        // --- Core Navigation Engine (The Fix) ---

        function updateTransform() {
            dom.world.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
        }

        // 1. Wheel Handling - The logic that fixes "Difficult Scrolling"
        dom.viewport.addEventListener('wheel', (e) => {
            
            // A. Check if user is hovering over a card body
            const isOverCard = e.target.closest('.card-body');
            
            // B. ZOOM: Ctrl + Wheel OR Pinch gesture (browsers often map pinch to Ctrl+Wheel)
            if (e.ctrlKey) {
                e.preventDefault();
                const delta = e.deltaY * -0.001;
                const newScale = Math.min(Math.max(0.1, state.scale + delta), 4);
                
                // Zoom towards mouse pointer logic
                const rect = dom.viewport.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate world space before zoom
                const worldX = (mouseX - state.x) / state.scale;
                const worldY = (mouseY - state.y) / state.scale;
                
                state.scale = newScale;
                
                // Recalculate x/y to keep mouse fixed
                state.x = mouseX - worldX * state.scale;
                state.y = mouseY - worldY * state.scale;
                
                updateTransform();
                return;
            }

            // C. CONTENT SCROLL: If over a card, let browser handle it naturally
            if (isOverCard) {
                // We do NOTHING here. Event propagates to card-body div. 
                // The CSS 'overscroll-behavior: contain' prevents the parent from moving.
                return; 
            }

            // D. PAN: If on background, wheel moves the canvas
            e.preventDefault(); // Stop browser back/forward swipes
            state.x -= e.deltaX;
            state.y -= e.deltaY;
            updateTransform();

        }, { passive: false }); // Passive false required to use preventDefault

        // 2. Drag Logic (Mouse users who prefer drag)
        dom.viewport.addEventListener('mousedown', (e) => {
            // Only drag if clicking background or Card Header
            if (e.target.closest('.card-body') || e.target.closest('.search-bar')) return;
            
            state.isDragging = true;
            state.startX = e.clientX - state.x;
            state.startY = e.clientY - state.y;
            dom.viewport.style.cursor = 'grabbing';
        });

        window.addEventListener('mouseup', () => {
            state.isDragging = false;
            dom.viewport.style.cursor = 'default';
        });

        window.addEventListener('mousemove', (e) => {
            if (!state.isDragging) return;
            e.preventDefault();
            state.x = e.clientX - state.startX;
            state.y = e.clientY - state.startY;
            updateTransform();
        });


        // --- Wikipedia Logic (Same as before, simplified) ---

        async function fetchPage(title) {
            const res = await fetch(`${API}&action=parse&page=${encodeURIComponent(title)}&format=json&prop=text|displaytitle&redirects=1&disableeditsection=1`);
            const data = await res.json();
            return data.parse ? { title: data.parse.displaytitle, html: data.parse.text['*'] } : null;
        }

        function createNode(title, parentStack = null) {
            const wrapper = document.createElement('div');
            wrapper.className = 'node-wrapper';

            const card = document.createElement('div');
            card.className = 'card';
            
            // Structure
            card.innerHTML = `
                <div class="card-header">
                    <span class="font-bold text-white truncate pr-4">${title}</span>
                    <i class="ri-close-line cursor-pointer hover:text-red-500" onclick="this.closest('.node-wrapper').remove()"></i>
                </div>
                <div class="card-body wiki-text">
                    <div class="flex flex-col items-center justify-center h-full text-gray-500 gap-2">
                        <div class="spinner border-gray-600 border-t-blue-500"></div>
                        <span class="text-xs">Loading Knowledge...</span>
                    </div>
                </div>
            `;

            wrapper.appendChild(card);

            if (!parentStack) {
                dom.world.innerHTML = '';
                dom.world.appendChild(wrapper);
                // Center camera roughly
                state.x = (window.innerWidth / 2) - 225;
                state.y = (window.innerHeight / 2) - 300;
                updateTransform();
            } else {
                parentStack.appendChild(wrapper);
            }

            // Animation
            gsap.from(card, { scale: 0.8, opacity: 0, duration: 0.4, ease: "back.out(1.7)" });

            // Fetch
            fetchPage(title).then(data => {
                if(!data) {
                    card.querySelector('.card-body').innerHTML = '<div class="p-4 text-red-400">Not found.</div>';
                    return;
                }
                
                const cleanHTML = DOMPurify.sanitize(data.html, { FORBID_TAGS: ['style','script','link'] });
                const body = card.querySelector('.card-body');
                body.innerHTML = cleanHTML;

                // Handle Links
                body.querySelectorAll('a').forEach(link => {
                    const href = link.getAttribute('href');
                    if(href && href.startsWith('/wiki/')) {
                        link.onclick = (e) => {
                            e.preventDefault();
                            const nextTitle = href.replace('/wiki/', '').split('#')[0];
                            spawnChild(wrapper, nextTitle);
                        }
                    } else {
                        link.target = "_blank";
                    }
                });
            });
        }

        function spawnChild(parentNodeWrapper, title) {
            let stack = parentNodeWrapper.querySelector('.children-stack');
            if (!stack) {
                stack = document.createElement('div');
                stack.className = 'children-stack';
                parentNodeWrapper.appendChild(stack);
            }
            createNode(title, stack);
        }

        // --- Search ---
        let debounce;
        dom.input.addEventListener('input', (e) => {
            clearTimeout(debounce);
            const q = e.target.value;
            if(q.length < 2) return;
            
            document.getElementById('loader').classList.remove('hidden');
            debounce = setTimeout(async () => {
                const res = await fetch(`${API}&action=opensearch&search=${encodeURIComponent(q)}&limit=5&format=json`);
                const data = await res.json();
                document.getElementById('loader').classList.add('hidden');
                
                dom.suggestions.innerHTML = '';
                if(data[1].length) {
                    dom.suggestions.classList.add('active');
                    data[1].forEach(t => {
                        const div = document.createElement('div');
                        div.className = 's-item';
                        div.innerText = t;
                        div.onclick = () => {
                            createNode(t);
                            dom.suggestions.classList.remove('active');
                            dom.input.value = '';
                        }
                        dom.suggestions.appendChild(div);
                    });
                }
            }, 300);
        });

        // Close suggestions on click outside
        window.addEventListener('click', (e) => {
            if(!e.target.closest('.search-bar')) dom.suggestions.classList.remove('active');
        });

        // Init
        createNode("Fractal");

    </script>
</body>
</html>
